# Однопроходные алгоритмы
"""
----------------------------------------------------------------
x->x было число получилось число
x->[x1,x2,...,xn] из числа происходит последовательность чисел
[x1,x2,...,xn]->x была последовательность чисел из нее получаем число, статистическая выжимка

[x1,x2,...,xn] ->y(n-1)   #n-1,n ниже y,x(подстрочный)
F(yn-1,xn)->yn            #n-1,n ниже y,x(подстрочный)
----------------------------------------------------------------
                            []  переход
подсчет               n     0    n+=1
сумма                 s     0    s+=x
произведение          p     1    p*=x
максимум              m          m=max(m,x), где            m=max(m,x) <=> if x>m:
поиск числа в потоке  f   false  f = f or x == x0                             m=x
----------------------------------------------------------------
                                Функции(с параметрами и без)

def hello():
    print('hello, world')
hello()

def hello(name):
    print('Hello,', name)
#требует параметр и теперь ему нужно подавать параметр
hello('John')
#Hello, John

#можно сделать значение параметра по умолчанию
def hello(name='World'):
    print('Hello,',name)
hello()
#Hello,World
Hello('John')
#Hello,John


def max2(x,y):          def max2(x,y):
    if x > y:               if x > y:
        return x   <=>          return x
    else:                   return y
        return y


def max3(x,y,z):
    return max2(x,max2(y,z)) (max2 вызывается дважды)
#можно смешить float и int,
#возможно использовать функцию и для строк (Duck Typing),
#если тип в параметрах не указывают



def hello_separated(name="World", separator="-"):
    print("Hello,",name,sep=separator) ('=' - не присваивание, это вызов функции принт с явным указанием параметра, чему равеным sep)

hello_separated("John","***") (строгий порядок параметров)
#Hello,***John
hello_separated(separator="***", name="World") (для необязательного указаняи места параметра)
#Hello,***World
----------------------------------------------------------------------
                                Структурное программирование

Проектирование "Сверху вниз"
Мы передаем информацию что сделать, где и конкретная точка, размер, когда и т.п.
Требуется некоторая формализация, в виде списка параметров

import graphics as gr

def build_house(window(где), upper_left_corner(угол дома), width):
    #Функция которая рисует дом
    width, height =calculate_sizes(width) (width уже есть,поэтому только height)
    (не нужна)pass #спасовать, ничего не делать, функция-пустышка

window = gr.GraphWin("Russian game", 300, 300)
build_house(window, gr.Point(100,100), 100)

print("Ура! Дом построен!")

#Нужна документация всего, как сделать что сделать архитекторы дизайнеры понимать как выглядит проект

#мы от функции верхнего уровня углубляемся в функции нижнего уровня, удаляемся в них


------------------------------------------------------------------------
                                    Алгоритмическая часть

Метод решения задачек такой как "Метод грубочий силы"(BruteForce)

Есть некоторые исходные данные, по исходным данным найти ответ

область определения ----> множество значений(получаем отсюда ответ)
Перебор всех ответов - метод грубой силы

def is_simple_number(x):
    #Определяет, является ли число простым, если простое возвращает True
    #а иначе False. x - целое положительное число
    divisor = 2
    while divisor < x:
        if x%divisor == 0:
            return False
        divisor+=1
    return True

help(is_simple_number)

def factorize_number(x):
    #Раскладывает число на множители.Печатает на экран
    #x - целое положительное
    divisor = 2
    while x > 1:
        if x%divisor==0:
            print(divisor)
            x//=divisor
        else:
            divisor+=1

-----------------------------------------------------------------------
                                Массивы( тип List )
генераторы массивов(BKB YTN)

A = [0]*1000  -->
top = 0
x = int(input())
while x != 0:
    A[top] = x
    top += 1
    x = int(input())
for k in range(4,-1,-1):
    print(A[k])
можно контролировать реальный уровень заполненности
------------------------------------------------------------------
                            алгоритмы с массивом
#копирование массива
#заранее известен размер массива
N=int(input())
A=[0]*N               нельзя A=[0]*N=B -- виновата ссылочная модель данных
B=[0]*N
for k in range(N):
    A[k] = int(input())
for k in range(N):
    B[k] = A[k]
или
for k in range(N):
    A[k] = int(input())
    B[k] = A[k]

C = A  --- C ссылается на список A
A[0] = 777
print(C[0]) #777

#копия списка
C = List(A)

--------------------------------------------------------------------

def array_search(A:list, N:int, x:int):
    #Осуществляет поиск числа x в массиве A
    #В диапазоне от 0 до N-1 индекса включительно
    #Возвращает индекс элемента x в массиве A.
    #или return -1, если такого нет.
    #Если в массиве несколько одинаковых элементов
    #равных x, то вернут индекс первого по счёту
    for k in range(N):
        if A[k] == x:
            return k
    return -1

def test_array_search():
    A1 = [1, 2, 3, 4, 5]
    m = array_search(A1, 5, 8)
    if m == -1:
        print('#test1 - ok')
    else:
        print('#test1 - fail')

    A2 = [-11, -2, -3, -4, -5]
    m = array_search(A2, 5, -3)
    if m == -1:
        print('#test2 - ok')
    else:
        print('#test2 - fail')

    A3 = [10, 20, 10, -234, 10]
    m = array_search(A3, 5, -3)
    if m == -1:
        print('#test3 - ok')
    else:
        print('#test3 - fail')

test_array_search()

------------------------------------------------------------
                   Алгоритм обращения массива

def invert_array(A:list, N:int):
    #Обращение массива(поворот задом-наперёд)
    #От 0 до N-1
    for k in range(N):
        A[k] = A[N-1-k]  --  не работает [1, 2, 3, 4, 5] --> [5, 4, 3, 4, 5]
        #лучше обмен двух переменных
        # x,y = y,x
        #A[k], A[N-1-k] = A[N-1-k], A[k]( но тоже не срабатывает, [1, 2, 3, 4, 5] --> [1, 2, 3, 4, 5]
        #надо:
    #for k in range(N//2):
        #A[k], A[N-1-k] = A[N-1-k], A[k]

def test_invert_array():
    A1 = [1, 2, 3, 4, 5]
    invert_array(A1, 5)
    if A1 == [5, 4, 3, 2, 1]:
        print('#test1 - ok')
    else:
        print('#test1 - fail')

    A2 = [0, 0, 0, 0, 0, 0, 0, 10]
    invert_array(A2, 8)
    if A1 == [10, 0, 0, 0, 0, 0, 0, 0]:
        print('#test1 - ok')
    else:
        print('#test1 - fail')
test_invert_array()


##B[k] = A[N-1-k]  ==  A[k] = A[N-1-k] (только в самом себе)
-----------------------------------------------------------------------------
                        Добавление элемента в массив в начало и конец списка
#циклический сдвиг в массиве

влево
[0, 1, 2, 3, 4] --> [1, 2, 3, 4, 0] --> [2, 3, 4, 0, 1]
вправо
[0, 1, 2, 3, 4] --> [4, 0, 1, 2, 3] --> [3, 4, 0, 1, 2]
    tmp - отдельный ящик куда мы кладем число которое перемещаем
#влево                                  #вправо
tmp = A[0]                             tmp = A[N-1]
for k in range(N-1):                   for k in range(N-2, -1, -1)
    A[k]=A[k+1]                            A[k+1] = A[k]
A[N-1] = tmp                           A[0] = tmp
--------------------------------------------------------------------------
                        Решето Эратосфена (проверка на простое и составное)
#храним bolleanы в массиве
N = 500
A = [True]*N
A[0]=A[1]=False
for k in range(2, N):
    if A[k]:  #if True
        for m in range(2*k, N, k):
            A[m] = False
print(A)
#for k in range(N):
#   print(k,'-', 'простое':if A[k] else:'составное') - условный апперант,
                                                проверяем условием в принте
---------------------------------------------------------------------------
.pop() - удаляет с конца списка значение и возвращает его

                    List comprehensions
A = [x**2 for x in range(10)] <==> A=[]
                                   for x in range(10):
                                      A.append(x**2)

добавить в начало списка элемент - применить циклический сдвиг

A = [1,2,3,4,5,7,12,9,6]           A = [1,2,3,4,5,7,12,9,6]
B = []                             B = [x**2 for x in A if x%2==0]
for x in A:                  <==>
    if x%2==0:                    B = [0 if x<0 else x**2 for x in A]
        B.append(x**2)            (тернарный оператор)

------------------------------------------------------------------














































"""